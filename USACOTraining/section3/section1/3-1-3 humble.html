<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hao Chen's website</title>
    </head>
    <body>
        <p>
            The description of this problem is fairly simple, but to solve it requires some thinking. From the size of the data we know that we can't list all possibilities out, which with be 2<sup>100</sup> cases. Instead, we will need to use the concept of DP to solve this problem. 
        </p>
        <p>
            First, we can create an array called dp, and dp[i] represents the ith humble number. in dp[0], we can put 1 there. then, loop through every index. Now, the naive implementation is to loop calculate every single combinition of previous humble numbers and prime numbers given and find the smallest one that is greater than dp[current - 1], but unfortunately this will have a TLE.
        </p>
        <p>
            A better way to do it is to to set up a last array to keep track of the index of the humble number you choose in order to make the result greater than dp[current]. we know that when we are loking for later solutions, they are greater than this, so a last array prevent us from choosing those humble numbers that are definitely not qualified.
        </p>
        <a href="USACO Training 3-1-3 humble.txt" target="_blank">Here is the code</a>
    </body>
</html>
